// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"stoke/internal/ent"
	"stoke/internal/ent/claim"
	"stoke/internal/ent/claimgroup"
	"stoke/internal/ent/grouplink"
	"stoke/internal/ent/privatekey"
	"stoke/internal/ent/user"

	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateClaim handles POST /claims requests.
func (h *OgentHandler) CreateClaim(ctx context.Context, req *CreateClaimReq) (CreateClaimRes, error) {
	b := h.client.Claim.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetShortName(req.ShortName)
	b.SetValue(req.Value)
	b.SetDescription(req.Description)
	// Add all edges.
	b.AddClaimGroupIDs(req.ClaimGroups...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Claim.Query().Where(claim.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewClaimCreate(e), nil
}

// ReadClaim handles GET /claims/{id} requests.
func (h *OgentHandler) ReadClaim(ctx context.Context, params ReadClaimParams) (ReadClaimRes, error) {
	q := h.client.Claim.Query().Where(claim.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewClaimRead(e), nil
}

// UpdateClaim handles PATCH /claims/{id} requests.
func (h *OgentHandler) UpdateClaim(ctx context.Context, req *UpdateClaimReq, params UpdateClaimParams) (UpdateClaimRes, error) {
	b := h.client.Claim.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.ShortName.Get(); ok {
		b.SetShortName(v)
	}
	if v, ok := req.Value.Get(); ok {
		b.SetValue(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	// Add all edges.
	if req.ClaimGroups != nil {
		b.ClearClaimGroups().AddClaimGroupIDs(req.ClaimGroups...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Claim.Query().Where(claim.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewClaimUpdate(e), nil
}

// DeleteClaim handles DELETE /claims/{id} requests.
func (h *OgentHandler) DeleteClaim(ctx context.Context, params DeleteClaimParams) (DeleteClaimRes, error) {
	err := h.client.Claim.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteClaimNoContent), nil

}

// ListClaim handles GET /claims requests.
func (h *OgentHandler) ListClaim(ctx context.Context, params ListClaimParams) (ListClaimRes, error) {
	q := h.client.Claim.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewClaimLists(es)
	return (*ListClaimOKApplicationJSON)(&r), nil
}

// ListClaimClaimGroups handles GET /claims/{id}/claim-groups requests.
func (h *OgentHandler) ListClaimClaimGroups(ctx context.Context, params ListClaimClaimGroupsParams) (ListClaimClaimGroupsRes, error) {
	q := h.client.Claim.Query().Where(claim.IDEQ(params.ID)).QueryClaimGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewClaimClaimGroupsLists(es)
	return (*ListClaimClaimGroupsOKApplicationJSON)(&r), nil
}

// CreateClaimGroup handles POST /claim-groups requests.
func (h *OgentHandler) CreateClaimGroup(ctx context.Context, req *CreateClaimGroupReq) (CreateClaimGroupRes, error) {
	b := h.client.ClaimGroup.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDescription(req.Description)
	// Add all edges.
	b.AddUserIDs(req.Users...)
	b.AddGroupLinkIDs(req.GroupLinks...)
	b.AddClaimIDs(req.Claims...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ClaimGroup.Query().Where(claimgroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewClaimGroupCreate(e), nil
}

// ReadClaimGroup handles GET /claim-groups/{id} requests.
func (h *OgentHandler) ReadClaimGroup(ctx context.Context, params ReadClaimGroupParams) (ReadClaimGroupRes, error) {
	q := h.client.ClaimGroup.Query().Where(claimgroup.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewClaimGroupRead(e), nil
}

// UpdateClaimGroup handles PATCH /claim-groups/{id} requests.
func (h *OgentHandler) UpdateClaimGroup(ctx context.Context, req *UpdateClaimGroupReq, params UpdateClaimGroupParams) (UpdateClaimGroupRes, error) {
	b := h.client.ClaimGroup.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	// Add all edges.
	if req.Users != nil {
		b.ClearUsers().AddUserIDs(req.Users...)
	}
	if req.GroupLinks != nil {
		b.ClearGroupLinks().AddGroupLinkIDs(req.GroupLinks...)
	}
	if req.Claims != nil {
		b.ClearClaims().AddClaimIDs(req.Claims...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ClaimGroup.Query().Where(claimgroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewClaimGroupUpdate(e), nil
}

// DeleteClaimGroup handles DELETE /claim-groups/{id} requests.
func (h *OgentHandler) DeleteClaimGroup(ctx context.Context, params DeleteClaimGroupParams) (DeleteClaimGroupRes, error) {
	err := h.client.ClaimGroup.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteClaimGroupNoContent), nil

}

// ListClaimGroup handles GET /claim-groups requests.
func (h *OgentHandler) ListClaimGroup(ctx context.Context, params ListClaimGroupParams) (ListClaimGroupRes, error) {
	q := h.client.ClaimGroup.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewClaimGroupLists(es)
	return (*ListClaimGroupOKApplicationJSON)(&r), nil
}

// ListClaimGroupUsers handles GET /claim-groups/{id}/users requests.
func (h *OgentHandler) ListClaimGroupUsers(ctx context.Context, params ListClaimGroupUsersParams) (ListClaimGroupUsersRes, error) {
	q := h.client.ClaimGroup.Query().Where(claimgroup.IDEQ(params.ID)).QueryUsers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewClaimGroupUsersLists(es)
	return (*ListClaimGroupUsersOKApplicationJSON)(&r), nil
}

// ListClaimGroupGroupLinks handles GET /claim-groups/{id}/group-links requests.
func (h *OgentHandler) ListClaimGroupGroupLinks(ctx context.Context, params ListClaimGroupGroupLinksParams) (ListClaimGroupGroupLinksRes, error) {
	q := h.client.ClaimGroup.Query().Where(claimgroup.IDEQ(params.ID)).QueryGroupLinks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewClaimGroupGroupLinksLists(es)
	return (*ListClaimGroupGroupLinksOKApplicationJSON)(&r), nil
}

// ListClaimGroupClaims handles GET /claim-groups/{id}/claims requests.
func (h *OgentHandler) ListClaimGroupClaims(ctx context.Context, params ListClaimGroupClaimsParams) (ListClaimGroupClaimsRes, error) {
	q := h.client.ClaimGroup.Query().Where(claimgroup.IDEQ(params.ID)).QueryClaims()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewClaimGroupClaimsLists(es)
	return (*ListClaimGroupClaimsOKApplicationJSON)(&r), nil
}

// CreateGroupLink handles POST /group-links requests.
func (h *OgentHandler) CreateGroupLink(ctx context.Context, req *CreateGroupLinkReq) (CreateGroupLinkRes, error) {
	b := h.client.GroupLink.Create()
	// Add all fields.
	b.SetType(req.Type)
	b.SetResourceSpec(req.ResourceSpec)
	// Add all edges.
	if v, ok := req.ClaimGroup.Get(); ok {
		b.SetClaimGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.GroupLink.Query().Where(grouplink.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupLinkCreate(e), nil
}

// ReadGroupLink handles GET /group-links/{id} requests.
func (h *OgentHandler) ReadGroupLink(ctx context.Context, params ReadGroupLinkParams) (ReadGroupLinkRes, error) {
	q := h.client.GroupLink.Query().Where(grouplink.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGroupLinkRead(e), nil
}

// UpdateGroupLink handles PATCH /group-links/{id} requests.
func (h *OgentHandler) UpdateGroupLink(ctx context.Context, req *UpdateGroupLinkReq, params UpdateGroupLinkParams) (UpdateGroupLinkRes, error) {
	b := h.client.GroupLink.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Type.Get(); ok {
		b.SetType(v)
	}
	if v, ok := req.ResourceSpec.Get(); ok {
		b.SetResourceSpec(v)
	}
	// Add all edges.
	if v, ok := req.ClaimGroup.Get(); ok {
		b.SetClaimGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.GroupLink.Query().Where(grouplink.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupLinkUpdate(e), nil
}

// DeleteGroupLink handles DELETE /group-links/{id} requests.
func (h *OgentHandler) DeleteGroupLink(ctx context.Context, params DeleteGroupLinkParams) (DeleteGroupLinkRes, error) {
	err := h.client.GroupLink.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteGroupLinkNoContent), nil

}

// ListGroupLink handles GET /group-links requests.
func (h *OgentHandler) ListGroupLink(ctx context.Context, params ListGroupLinkParams) (ListGroupLinkRes, error) {
	q := h.client.GroupLink.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGroupLinkLists(es)
	return (*ListGroupLinkOKApplicationJSON)(&r), nil
}

// ReadGroupLinkClaimGroup handles GET /group-links/{id}/claim-group requests.
func (h *OgentHandler) ReadGroupLinkClaimGroup(ctx context.Context, params ReadGroupLinkClaimGroupParams) (ReadGroupLinkClaimGroupRes, error) {
	q := h.client.GroupLink.Query().Where(grouplink.IDEQ(params.ID)).QueryClaimGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGroupLinkClaimGroupRead(e), nil
}

// ListPrivateKey handles GET /private-keys requests.
func (h *OgentHandler) ListPrivateKey(ctx context.Context, params ListPrivateKeyParams) (ListPrivateKeyRes, error) {
	q := h.client.PrivateKey.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPrivateKeyLists(es)
	return (*ListPrivateKeyOKApplicationJSON)(&r), nil
}

// ReadPrivateKey handles GET /private-keys/{id} requests.
func (h *OgentHandler) ReadPrivateKey(ctx context.Context, params ReadPrivateKeyParams) (ReadPrivateKeyRes, error) {
	q := h.client.PrivateKey.Query().Where(privatekey.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPrivateKeyRead(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req *UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Fname.Get(); ok {
		b.SetFname(v)
	}
	if v, ok := req.Lname.Get(); ok {
		b.SetLname(v)
	}
	if v, ok := req.Source.Get(); ok {
		b.SetSource(v)
	}
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	if v, ok := req.Username.Get(); ok {
		b.SetUsername(v)
	}
	// Add all edges.
	if req.ClaimGroups != nil {
		b.ClearClaimGroups().AddClaimGroupIDs(req.ClaimGroups...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// ListUserClaimGroups handles GET /users/{id}/claim-groups requests.
func (h *OgentHandler) ListUserClaimGroups(ctx context.Context, params ListUserClaimGroupsParams) (ListUserClaimGroupsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryClaimGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserClaimGroupsLists(es)
	return (*ListUserClaimGroupsOKApplicationJSON)(&r), nil
}
